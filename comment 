Sure! Here’s your updated reply with that line added:


---

Thanks, Chris!

Just to clarify on the script — it does exist in the package.json under root/tests/e2e/package.json as test:pipeline.

The flow I described above was tested thoroughly before pushing the changes, and it worked exactly as expected in all the scenarios.

The reason I retained the name test:pipeline is because there are two related scripts — test:local (for local runs) and test:pipeline (used in GitHub Actions). The pipeline script takes a --pipeline flag, which helps control whether the browser runs in headless mode for CI or headed mode for local.

If we rename it, we might lose that clarity or consistency, but I’m happy to adjust it if you feel a different name would make things more intuitive.

Got it! Here’s the refined ending for your comment:


---

If renaming helps improve clarity, I can update them to something like test:e2e:pipeline and test:e2e:local to better reflect their purpose — just let me know if that works for you!


Yes, here’s a clean and slightly more refined version that includes that distinction:


---

Thanks, Chris!

Just to clarify — the test:pipeline script is defined in the e2e package’s package.json, and that’s what Turbo is executing.

As for combining the steps: the dashboard build is a strict dependency since we need it fully built before we can serve it and check for liveliness before running the tests. The backend build, on the other hand, is included purely for Turbo's change detection — to help determine whether the E2E tests need to re-run.

We kept them as separate steps for clarity and easier debugging, but happy to refactor and combine if you feel strongly about it.

Yes, here’s a cleaner and clearer version of that question you can use:


---

Also, just checking — shall we combine the frontend and backend builds together, then serve the dashboard, and finally execute the E2E test as a single step? Let me know if that feels cleaner to you.


logoutTestPack.forEach(({ ck, csrf, csrfToken, description, response: { status, body } }) => {
  apiTest(description, async ({ baseUrl }) => {
    const request = spec()
      .post(`${baseUrl}/secure/api/logout`)
      .withHeaders({ 'Content-Type': 'application/json' });

    // Handle cookies
    const cookieParts = [`ck=${ck}`];
    if (csrf) cookieParts.push(`CSRF=${csrf}`);
    request.withCookies(cookieParts.join(';'));

    // Handle request body
    if (csrfToken) {
      request.withJson({ csrfToken });
    }

    await request.expectStatus(status).expectBody(body);
  });
});

Yes, that's a great addition — here's how you can naturally fit that in:


---

Understood the expectation to remove the boolean flags and handle inclusion dynamically.
Replaced them with two optional fields: csrfCookie (existing one, previously named csrf) and csrfToken. Based on their presence, cookies and body are conditionally added in the test runner — keeping the interface clean and avoiding potentially confusing control flags.


---

That phrasing keeps it concise and clear. Let me know if you want to tweak the tone slightly!








